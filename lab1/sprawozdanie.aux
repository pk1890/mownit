\relax 
\providecommand\zref@newlabel[2]{}
\@writefile{toc}{\contentsline {chapter}{\numberline {1}LAB 1}{1}\protected@file@percent }
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{locode}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {section}{\numberline {1.1}Napisz program, kt\IeC {\'o}ry wyznaczy epsilon maszynowe dla typu float i double w j\IeC {\k e}zyku C oraz float w Python przy pomocy programu rekurencyjnego. }{1}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Kod w C++:}{1}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Kod w Pythonie:}{3}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {1.2}Napisz dwa programy w j\IeC {\k e}zyku C b\IeC {\k a}d\IeC {\'z} Python, gdzie pierwszy zachowuje si\IeC {\k e} niestabilnie i wyja\IeC {\'s}nij dlaczego, podczas gdy drugi zachowuje si\IeC {\k e} stabilnie i jest ulepszon\IeC {\k a} wersj\IeC {\k a} pierwszego programu. }{4}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {1.3}Sumowanie liczb pojedynczej precyzji w j\IeC {\k e}zyku C: }{5}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {1.3.1}Napisz program, kt\IeC {\'o}ry oblicza sum\IeC {\k e} N liczb pojedynczej precyzji przechowywanych w tablicy o N= $10^7$ elementach. Tablica wype\IeC {\l }niona jest t\IeC {\k a} sam\IeC {\k a} warto\IeC {\'s}ci\IeC {\k a} v z przedzia\IeC {\l }u [0.1,0.9] np.v= 0.53125. Zaproponuj dwa takie v, gdzie b\IeC {\l }\IeC {\k e}dy b\IeC {\k e}d\IeC {\k a} najmniejsze i najwi\IeC {\k e}ksze w czasie sumowania.}{5}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {1.1}{\ignorespaces Wykres b\IeC {\l }\IeC {\k e}du wzgl\IeC {\k e}dnego od iteracji sumy dla v = (0.25+0.125)/2\relax }}{7}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {1.4}Algorytm Kahana w j\IeC {\k e}zyku C:}{8}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {1.5}Napisz program w j\IeC {\k e}zyku C, kt\IeC {\'o}ry wyznaczy K najmniejszych liczb ze zbioru N elementowej nieposortowanej tablicy liczb typu float bazuj\IeC {\k a}c na idei sortowania kube\IeC {\l }kowego i algorytmie zaprezentowanym i wyt\IeC {\l }umaczonym na zaj\IeC {\k e}ciach na tablicy. Dokonaj analizy poprawno\IeC {\'s}ci dzia\IeC {\l }ania algorytmu i czasu wykonania dla innego algorytmu wyszukuj\IeC {\k a}cego k K najmniejszych liczb dla zbioru liczb wygenerowanych w zakresach: $<0.0,0.3>$ i $<0.0, 3.0>$. }{11}\protected@file@percent }
\@writefile{lol}{\contentsline {lstlisting}{test0.3.txt}{13}\protected@file@percent }
\@writefile{lol}{\contentsline {lstlisting}{test3.txt}{14}\protected@file@percent }
\@writefile{toc}{\contentsline {chapter}{\numberline {2}LAB 1}{16}\protected@file@percent }
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{locode}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {section}{\numberline {2.1}Napisz program, kt\IeC {\'o}ry wyznaczy epsilon maszynowe dla typu float i double w j\IeC {\k e}zyku C oraz float w Python przy pomocy programu rekurencyjnego. }{16}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Kod w C++:}{16}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Kod w Pythonie:}{18}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {2.2}Napisz dwa programy w j\IeC {\k e}zyku C b\IeC {\k a}d\IeC {\'z} Python, gdzie pierwszy zachowuje si\IeC {\k e} niestabilnie i wyja\IeC {\'s}nij dlaczego, podczas gdy drugi zachowuje si\IeC {\k e} stabilnie i jest ulepszon\IeC {\k a} wersj\IeC {\k a} pierwszego programu. }{19}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {2.3}Sumowanie liczb pojedynczej precyzji w j\IeC {\k e}zyku C: }{20}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3.1}Napisz program, kt\IeC {\'o}ry oblicza sum\IeC {\k e} N liczb pojedynczej precyzji przechowywanych w tablicy o N= $10^7$ elementach. Tablica wype\IeC {\l }niona jest t\IeC {\k a} sam\IeC {\k a} warto\IeC {\'s}ci\IeC {\k a} v z przedzia\IeC {\l }u [0.1,0.9] np.v= 0.53125. Zaproponuj dwa takie v, gdzie b\IeC {\l }\IeC {\k e}dy b\IeC {\k e}d\IeC {\k a} najmniejsze i najwi\IeC {\k e}ksze w czasie sumowania.}{20}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {2.1}{\ignorespaces Wykres b\IeC {\l }\IeC {\k e}du wzgl\IeC {\k e}dnego od iteracji sumy dla v = (0.25+0.125)/2\relax }}{22}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {2.4}Algorytm Kahana w j\IeC {\k e}zyku C:}{23}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {2.5}Napisz program w j\IeC {\k e}zyku C, kt\IeC {\'o}ry wyznaczy K najmniejszych liczb ze zbioru N elementowej nieposortowanej tablicy liczb typu float bazuj\IeC {\k a}c na idei sortowania kube\IeC {\l }kowego i algorytmie zaprezentowanym i wyt\IeC {\l }umaczonym na zaj\IeC {\k e}ciach na tablicy. Dokonaj analizy poprawno\IeC {\'s}ci dzia\IeC {\l }ania algorytmu i czasu wykonania dla innego algorytmu wyszukuj\IeC {\k a}cego k K najmniejszych liczb dla zbioru liczb wygenerowanych w zakresach: $<0.0,0.3>$ i $<0.0, 3.0>$. }{26}\protected@file@percent }
\@writefile{lol}{\contentsline {lstlisting}{test0.3.txt}{28}\protected@file@percent }
\@writefile{lol}{\contentsline {lstlisting}{test3.txt}{29}\protected@file@percent }
\@writefile{toc}{\contentsline {chapter}{\numberline {3}LAB 2}{31}\protected@file@percent }
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{locode}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {section}{\numberline {3.1}Napisz (Python)}{31}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {3.2}Napisz i sprawd\IeC {\'z} funkcj\IeC {\k e} dokonuj\IeC {\k a}c\IeC {\k a} faktoryzacji A=LU macierzy A. Zastosuj cz\IeC {\k e}\IeC {\'s}ciowe poszukiwanie elementu wiod\IeC {\k a}cego oraz skalowanie.}{33}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {3.3}Implementacja algorytmu Floyd-Warshall przy pomocy mno\IeC {\.z}enia macierzy. J\IeC {\k e}zyk Python b\IeC {\k a}d\IeC {\'z} C/C++ i prosty przyk\IeC {\l }ad z por\IeC {\'o}wnaniem wydajno\IeC {\'s}ciowym do wersji z p\IeC {\k e}tlami mno\IeC {\.z}\IeC {\k a}cymi. http://phdopen.mimuw.edu.pl/lato07/paths1.pdf }{34}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {3.4}Zaimplementuj 3 metody mno\IeC {\.z}enia macierzy rzadkich wedle format\IeC {\'o}w zaprezentowanych pod wskazanym linkiem: https://docs.nvidia.com/cuda/cusparse/index.html (COO/CSR/CSC/ELL) i por\IeC {\'o}wnaj jak ilo\IeC {\'s}\IeC {\'c} zer wp\IeC {\l }ywa na czas mno\IeC {\.z}enia macierzy i ilo\IeC {\'s}\IeC {\'c} zu\IeC {\.z}ytej pami\IeC {\k e}ci. Por\IeC {\'o}wnanie dokonaj do standardowej metody mno\IeC {\.z}enia macierzy o z\IeC {\l }o\IeC {\.z}ono\IeC {\'s}ci $N^3$. J\IeC {\k e}zyk C/C++. Uszczeg\IeC {\'o}\IeC {\l }owienie: mo\IeC {\.z}na wykorzysta\IeC {\'c} https://www.it.uu.se/education/phd\_studies/phd\_courses/pasc/lecture-1 i mo\IeC {\.z}na pokaza\IeC {\'c} to na przyk\IeC {\l }adzie mno\IeC {\.z}enia macierz-wektor. }{36}\protected@file@percent }
\@writefile{toc}{\contentsline {chapter}{\numberline {4}LAB 3}{44}\protected@file@percent }
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{locode}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {section}{\numberline {4.1}Napisz w Python b\IeC {\k a}d\IeC {\'z} C/C++ funkcj\IeC {\k e} rozwi\IeC {\k a}zuj\IeC {\k a}c\IeC {\k a} przy pomocy metody bisekcji funkcj\IeC {\k e} f. Funkcja przyjmuje nast\IeC {\k e}puj\IeC {\k a}ce argumenty: kra\IeC {\'n}ce przedzia\IeC {\l }u, b\IeC {\l }\IeC {\k a}d bezwzgl\IeC {\k e}dny oblicze\IeC {\'n}. Funkcja ma zwraca\IeC {\'c} wyznaczone miejsce zerowe i liczb\IeC {\k e} iteracji potrzebn\IeC {\k a} do uzyskania okre\IeC {\'s}lonej dok\IeC {\l }adno\IeC {\'s}ci. Przetestuj dzia\IeC {\l }anie metody dla funkcji podanych na pocz\IeC {\k a}tku instrukcji. Napisz w Python b\IeC {\k a}d\IeC {\'z} C/C++ funkcj\IeC {\k e} rozwi\IeC {\k a}zuj\IeC {\k a}c\IeC {\k a} przy pomocy metody bisekcji funkcj\IeC {\k e} f. Funkcja przyjmuje nast\IeC {\k e}puj\IeC {\k a}ce argumenty: kra\IeC {\'n}ce przedzia\IeC {\l }u, b\IeC {\l }\IeC {\k a}d bezwzgl\IeC {\k e}dny oblicze\IeC {\'n}. }{44}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {4.2}Napisz w Python b\IeC {\k a}d\IeC {\'z} C/C++ funkcj\IeC {\k e} rozwi\IeC {\k a}zuj\IeC {\k a}c\IeC {\k a} przy pomocy metody Newtona funkcj\IeC {\k e} f. Funkcja ma wykorzystywa\IeC {\'c} dwa kryteria stopu: maksymaln\IeC {\k a} liczb\IeC {\k e} iteracji, modu\IeC {\l } r\IeC {\'o}\IeC {\.z}nicy kolejnych przybli\IeC {\.z}e\IeC {\'n} mniejszy od danej warto\IeC {\'s}ci eps. Opr\IeC {\'o}cz przybli\IeC {\.z}onej warto\IeC {\'s}ci pierwiastka funkcja ma zwr\IeC {\'o}ci\IeC {\'c} liczb\IeC {\k e} iteracji potrzebn\IeC {\k a} do uzyskania okre\IeC {\'s}lonej dok\IeC {\l }adno\IeC {\'s}ci eps. Por\IeC {\'o}wnaj zbie\IeC {\.z}no\IeC {\'s}\IeC {\'c} metody ze zbie\IeC {\.z}no\IeC {\'s}ci\IeC {\k a} uzyskan\IeC {\k a} dla metody bisekcji. Napisz w Python b\IeC {\k a}d\IeC {\'z} C/C++ funkcj\IeC {\k e} rozwi\IeC {\k a}zuj\IeC {\k a}c\IeC {\k a} przy pomocy metody bisekcji funkcj\IeC {\k e} f. Funkcja przyjmuje nast\IeC {\k e}puj\IeC {\k a}ce argumenty: kra\IeC {\'n}ce przedzia\IeC {\l }u, b\IeC {\l }\IeC {\k a}d bezwzgl\IeC {\k e}dny oblicze\IeC {\'n}. }{45}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {4.3}Napisz w Python b\IeC {\k a}d\IeC {\'z} C/C++ funkcj\IeC {\k e} rozwi\IeC {\k a}zuj\IeC {\k a}c\IeC {\k a} przy pomocy metody Newtona funkcj\IeC {\k e} f. Funkcja ma wykorzystywa\IeC {\'c} dwa kryteria stopu: maksymaln\IeC {\k a} liczb\IeC {\k e} iteracji, modu\IeC {\l } r\IeC {\'o}\IeC {\.z}nicy kolejnych przybli\IeC {\.z}e\IeC {\'n} mniejszy od danej warto\IeC {\'s}ci eps. Opr\IeC {\'o}cz przybli\IeC {\.z}onej warto\IeC {\'s}ci pierwiastka funkcja ma zwr\IeC {\'o}ci\IeC {\'c} liczb\IeC {\k e} iteracji potrzebn\IeC {\k a} do uzyskania okre\IeC {\'s}lonej dok\IeC {\l }adno\IeC {\'s}ci eps. Por\IeC {\'o}wnaj zbie\IeC {\.z}no\IeC {\'s}\IeC {\'c} metody ze zbie\IeC {\.z}no\IeC {\'s}ci\IeC {\k a} uzyskan\IeC {\k a} dla metody bisekcji. Napisz w Python b\IeC {\k a}d\IeC {\'z} C/C++ funkcj\IeC {\k e} rozwi\IeC {\k a}zuj\IeC {\k a}c\IeC {\k a} przy pomocy metody bisekcji funkcj\IeC {\k e} f. Funkcja przyjmuje nast\IeC {\k e}puj\IeC {\k a}ce argumenty: kra\IeC {\'n}ce przedzia\IeC {\l }u, b\IeC {\l }\IeC {\k a}d bezwzgl\IeC {\k e}dny oblicze\IeC {\'n}. }{45}\protected@file@percent }
\gdef\minted@oldcachelist{,
  default-pyg-prefix.pygstyle,
  default.pygstyle,
  5415819C5800451EE0FC63DC3BDCCD54AEA95202991DD2D36BA5033EB063D7FA.pygtex,
  427A93381B33CF5C6F878474C3D08A6F09089D417FC774654C75F87A0BBB441B.pygtex,
  CAB4156B1C7D30FDDD2CA283304406B709089D417FC774654C75F87A0BBB441B.pygtex,
  42E31915E48F9FD32E0FDD6F54C7697109089D417FC774654C75F87A0BBB441B.pygtex,
  BED9868FE72F3530CAB83C2A65313F8309089D417FC774654C75F87A0BBB441B.pygtex,
  3C773F061CBF7EA24B13E8192C16C0D2AEA95202991DD2D36BA5033EB063D7FA.pygtex,
  14AA21D695B8B21AECD7AD2378796A2709089D417FC774654C75F87A0BBB441B.pygtex,
  1BF13A94641450EE0A400003923D047AAEA95202991DD2D36BA5033EB063D7FA.pygtex,
  2133E8A799B8E1638F061EC90C6E98D6AEA95202991DD2D36BA5033EB063D7FA.pygtex,
  8C4533966E7AC496DE0E2C092FF7EBA0AEA95202991DD2D36BA5033EB063D7FA.pygtex,
  5415819C5800451EE0FC63DC3BDCCD54AEA95202991DD2D36BA5033EB063D7FA.pygtex,
  427A93381B33CF5C6F878474C3D08A6F09089D417FC774654C75F87A0BBB441B.pygtex,
  CAB4156B1C7D30FDDD2CA283304406B709089D417FC774654C75F87A0BBB441B.pygtex,
  42E31915E48F9FD32E0FDD6F54C7697109089D417FC774654C75F87A0BBB441B.pygtex,
  BED9868FE72F3530CAB83C2A65313F8309089D417FC774654C75F87A0BBB441B.pygtex,
  3C773F061CBF7EA24B13E8192C16C0D2AEA95202991DD2D36BA5033EB063D7FA.pygtex,
  14AA21D695B8B21AECD7AD2378796A2709089D417FC774654C75F87A0BBB441B.pygtex,
  1BF13A94641450EE0A400003923D047AAEA95202991DD2D36BA5033EB063D7FA.pygtex,
  2133E8A799B8E1638F061EC90C6E98D6AEA95202991DD2D36BA5033EB063D7FA.pygtex,
  8C4533966E7AC496DE0E2C092FF7EBA0AEA95202991DD2D36BA5033EB063D7FA.pygtex,
  B09C8DA3534D0DE1B62F5A9AAE2B8FE109089D417FC774654C75F87A0BBB441B.pygtex,
  4D2610E23BF1958DBD1318879EF3DBBF09089D417FC774654C75F87A0BBB441B.pygtex,
  AC6C71CA92EA74570B9F19B64F12A4B909089D417FC774654C75F87A0BBB441B.pygtex,
  758E21891F36A493A250012BA30A8DF9AEA95202991DD2D36BA5033EB063D7FA.pygtex,
  02D5554134B5578A4C08A5BAB3570C7609089D417FC774654C75F87A0BBB441B.pygtex,
  4E68B5F4137352EDBD8C7CB8E0E6B61909089D417FC774654C75F87A0BBB441B.pygtex,
  57294E8EB6BAA0245C7B636F7D60355D09089D417FC774654C75F87A0BBB441B.pygtex}
\@writefile{lof}{\contentsline {figure}{\numberline {4.1}{\ignorespaces Wykres funkcji a\relax }}{46}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {4.2}{\ignorespaces Wykres funkcji b\relax }}{46}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {4.4}Podsumowanie}{46}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.4.1}Wykresy funkcji}{46}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {4.3}{\ignorespaces Wykres funkcji c\relax }}{46}\protected@file@percent }
